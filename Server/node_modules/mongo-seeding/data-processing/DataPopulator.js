"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../common");
const _1 = require(".");
class DataPopulator {
    constructor(supportedExtensions) {
        if (supportedExtensions.length === 0) {
            throw new Error('Array of supported extensions must not be empty');
        }
        this.supportedExtensions = supportedExtensions;
    }
    populate(inputDirectory) {
        const subdirectories = _1.fileSystem.listValidDirectories(inputDirectory);
        return this.readCollections(subdirectories, inputDirectory);
    }
    readCollections(directories, inputDirectory) {
        return directories.reduce((collections, directoryName) => {
            const relativePath = `${inputDirectory}/${directoryName}`;
            const collection = this.readCollection(relativePath, directoryName);
            if (collection) {
                collections.push(collection);
            }
            return collections;
        }, []);
    }
    readCollection(path, directoryName) {
        const name = this.getCollectionName(directoryName);
        const documents = this.populateDocumentsContent(path);
        if (!documents) {
            return null;
        }
        return {
            name,
            documents,
        };
    }
    populateDocumentsContent(collectionPath) {
        const fileNames = _1.fileSystem.listFileNames(collectionPath);
        if (fileNames.length === 0) {
            common_1.log(`Directory '${collectionPath}' is empty. Skipping...`);
            return;
        }
        const documentFileNames = _1.fileSystem.filterSupportedDocumentFileNames(fileNames, this.supportedExtensions);
        if (documentFileNames.length === 0) {
            common_1.log(`No supported files found in directory '${collectionPath}'. Skipping...`);
            return;
        }
        const documentPaths = documentFileNames.map(fileName => `${collectionPath}/${fileName}`);
        return _1.fileSystem.readFilesContent(documentPaths);
    }
    getCollectionName(directoryName) {
        const separators = /\s*[-_\.\s]\s*/;
        let collectionName;
        if (directoryName.match(separators)) {
            collectionName = directoryName.split(separators)[1];
        }
        else {
            collectionName = directoryName;
        }
        return collectionName;
    }
}
exports.DataPopulator = DataPopulator;
//# sourceMappingURL=DataPopulator.js.map